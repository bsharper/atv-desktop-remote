const files = {
    "wsserver.py": "import os\nimport sys\nimport json\nimport pyatv\nimport random\nimport asyncio\nfrom pyatv.const import InputAction\nimport websockets\n\nimport logging\nlogger = logging.getLogger('websockets')\nlogger.setLevel(logging.DEBUG)\nlogger.addHandler(logging.StreamHandler())\n\n\ninterface = pyatv.interface\npair = pyatv.pair\nProtocol = pyatv.const.Protocol\n\n\nmy_name = os.path.basename(sys.argv[0])\n\nloop = asyncio.get_event_loop()\nscan_lookup = {}\npairing_atv = False\nactive_pairing = False\nactive_device = False\nactive_remote = False\nactive_ws = False\ndefault_port = 8765\npairing_creds = {}\n\nclass ATVKeyboardListener(interface.KeyboardListener):\n    global active_ws\n    def focusstate_update(self, old_state, new_state):\n        print('Focus state changed from {0:s} to {1:s}'.format(old_state, new_state), flush=True)\n        if active_ws:\n            try:\n                loop.run_until_complete(sendCommand(active_ws, \"keyboard_changestate\", [old_state, new_state]))\n            except Exception as ex:\n                print (f\"change state error: {ex}\", flush=True)\n                \n\n\nasync def sendCommand (ws, command, data=[]):\n    r = {\"command\": command, \"data\": data}\n    await ws.send(json.dumps(r))\n\nasync def parseRequest(j, websocket):\n    global scan_lookup, pairing_atv, active_pairing, active_device, active_remote, active_ws, pairing_creds\n    active_ws = websocket\n    if \"cmd\" in j.keys():\n        cmd = j[\"cmd\"]\n    else:\n        return\n    #print (f\"got command: {cmd}\", flush=True)\n    \n    data = False\n    if \"data\" in j.keys():\n        data = j[\"data\"]\n    \n    if cmd == \"quit\":\n        print (\"quit command\")\n        await asyncio.sleep(0.5)\n        sys.exit(0)\n        return\n    \n    if cmd == \"scan\":\n        atvs = await pyatv.scan(loop)\n        ar = []\n        scan_lookup = {}\n        for atv in atvs:\n            txt = f\"{atv.name} ({atv.address})\"\n            ar.append(txt)\n            scan_lookup[txt] = atv\n\n        await sendCommand(websocket, \"scanResult\", ar)\n\n    if cmd == \"echo\":\n        await sendCommand(websocket, \"echo_reply\", data)\n\n    if cmd == \"startPair\":\n        print (\"startPair\")\n        atv = scan_lookup[data]\n        pairing_atv = atv\n        print (\"pairing atv %s\" % (atv))\n        pairing = await pair(atv, Protocol.AirPlay, loop)\n        active_pairing = pairing\n        await pairing.begin()\n\n    if cmd == \"finishPair1\":\n        print(\"finishPair %s\" % (data))\n        pairing = active_pairing\n        pairing.pin(data)\n        await pairing.finish()\n        if pairing.has_paired:\n            print(\"Paired with device!\")\n            print(\"Credentials:\", pairing.service.credentials)\n        else:\n            print(\"Did not pair with device!\")\n            return\n        creds = pairing.service.credentials\n        id = pairing_atv.identifier\n        nj = {\"credentials\": creds, \"identifier\": id}\n        pairing_creds = nj\n        await sendCommand(websocket, \"startPair2\")\n        #await sendCommand(websocket, \"pairCredentials1\", nj)\n        atv = pairing_atv\n        print (\"pairing atv %s\" % (atv))\n        pairing = await pair(atv, Protocol.Companion, loop)\n        active_pairing = pairing\n        await pairing.begin()\n\n    if cmd == \"finishPair2\":\n        print(\"finishPair %s\" % (data))\n        pairing = active_pairing\n        pairing.pin(data)\n        await pairing.finish()\n        if pairing.has_paired:\n            print(\"Paired with device!\")\n            print(\"Credentials:\", pairing.service.credentials)\n        else:\n            print(\"Did not pair with device!\")\n        pairing_creds[\"Companion\"] = pairing.service.credentials\n        await sendCommand(websocket, \"pairCredentials\", pairing_creds)\n    \n    \n    if cmd == \"finishPair\":\n        print(\"finishPair %s\" % (data))\n        pairing = active_pairing\n        pairing.pin(data)\n        await pairing.finish()\n        if pairing.has_paired:\n            print(\"Paired with device!\")\n            print(\"Credentials:\", pairing.service.credentials)\n        else:\n            print(\"Did not pair with device!\")\n        creds = pairing.service.credentials\n        id = pairing_atv.identifier\n        nj = {\"credentials\": creds, \"identifier\": id}\n        await sendCommand(websocket, \"pairCredentials\", nj)\n\n    if cmd == \"kbfocus\":\n        if not active_device:\n            return\n        kbfocus = active_device.keyboard.text_focus_state == pyatv.const.KeyboardFocusState.Focused\n        await sendCommand(websocket, \"kbfocus-status\", kbfocus)\n    \n    if cmd == \"settext\":\n        text = data[\"text\"]\n        if active_device.keyboard.text_focus_state != pyatv.const.KeyboardFocusState.Focused:\n            return\n        await active_device.keyboard.text_set(text)\n    \n    if cmd == \"gettext\":\n        print (f\"gettext focus compare {active_device.keyboard.text_focus_state} == {pyatv.const.KeyboardFocusState.Focused}\", flush=True)\n        if active_device.keyboard.text_focus_state != pyatv.const.KeyboardFocusState.Focused:\n            return\n        ctext = await active_device.keyboard.text_get()\n        print (f\"Current text: {ctext}\", flush=True)\n        await sendCommand(websocket, \"current-text\", ctext)\n    \n    if cmd == \"connect\":\n        id = data[\"identifier\"]\n        creds = data[\"credentials\"]\n        stored_credentials = { Protocol.AirPlay: creds }\n        if \"Companion\" in data.keys():\n            companion_creds = data[\"Companion\"]\n            stored_credentials[Protocol.Companion] = companion_creds\n        \n        print (\"stored_credentials %s\" % (stored_credentials))\n        atvs = await pyatv.scan(loop, identifier=id)\n        atv = atvs[0]\n        for protocol, credentials in stored_credentials.items():\n            print (\"Setting protocol %s with credentials %s\" % (str(protocol), credentials))\n            atv.set_credentials(protocol, credentials)\n        try:\n            device = await pyatv.connect(atv, loop)\n            remote = device.remote_control\n            active_device = device\n            active_remote = remote\n            kblistener = ATVKeyboardListener()\n            device.keyboard.listener = kblistener\n            await sendCommand(websocket, \"connected\")\n        except Exception as ex:\n            print (\"Failed to connect\")\n            await sendCommand(websocket, \"connection_failure\")\n    \n    if cmd == \"is_connected\":\n        ic = \"true\" if active_remote else \"false\"\n        await sendCommand(websocket, \"is_connected\", ic)\n        #await active_remote.menu()\n    \n    if cmd == \"key\":\n        valid_keys = ['play_pause', 'left', 'right', 'down', 'up', 'select', 'menu', 'top_menu', 'home', 'home_hold', 'skip_backward', 'skip_forward', 'volume_up', 'volume_down']\n        no_action_keys = ['volume_up', 'volume_down', 'play_pause', 'home_hold']\n        #taction = InputAction[\"SingleTap\"]\n        taction = False\n        key = data\n        if not isinstance(data, str):\n            key = data['key']\n            taction = InputAction[data['taction']]\n    \n        if key in valid_keys:\n            if key in no_action_keys or (not taction):\n                r = await getattr(active_remote, key)()\n            else:\n                r = await getattr(active_remote, key)(taction)\n            #print (r)\n\nasync def close_active_device():\n    try:\n        if active_device:\n            await active_device.close()\n    except Exception as ex:\n        print (\"Error closing active_device: %s\" %(ex))\n\nasync def reset_globals():\n    global scan_lookup, pairing_atv, active_pairing, active_device, active_remote, active_ws\n    print (\"Resetting global variables\")\n    scan_lookup = {}\n    \n    pairing_atv = False\n    active_pairing = False\n    active_device = False\n    active_remote = False\n    active_ws = False\n\nkeep_running = True\n\n\nasync def check_exit_file():\n    global keep_running\n    if os.path.exists('stopserver'):\n        os.unlink('stopserver')\n\n    while keep_running:\n        await asyncio.sleep(0.5)\n        fe = os.path.exists('stopserver')\n        txt = \"found\" if fe else \"not found\"\n        #print (\"stopserver %s\" % (txt), flush=True)\n        if fe:\n            print (\"exiting\")\n            keep_running = False\n            os.unlink('stopserver')\n            sys.exit(0)\n\n\nasync def ws_main(websocket):\n    #await reset_globals()\n    await close_active_device()\n    async for message in websocket:\n        try:\n            j = json.loads(message)\n        except Exception as ex:\n            print (\"Error parsing message: %s\\n%s\" % (str(ex), message))\n            continue\n        \n        await parseRequest(j, websocket)\n\nasync def main(port):\n    global keep_running\n    width = 80\n    txt = \"%s WebSocket - ATV Server\" % (my_name)\n    print (\"=\"*width)\n    print (txt.center(width))\n    print (\"=\"*width, flush=True)\n    task = asyncio.create_task(check_exit_file())\n\n    async with websockets.serve(ws_main, \"localhost\", port):\n        try:\n            await asyncio.Future()  # run forever\n        except Exception as ex:\n            print (ex)\n            sys.exit(0)\n\n\n\nif __name__ == \"__main__\":\n    args = sys.argv[1:]\n    port = default_port\n    if len(args) > 0:\n        if args[0] in [\"-h\", \"--help\", \"-?\", \"/?\"]:\n            print (\"Usage: %s (port_number)\\n\\n Port number by default is %d\" % (my_name, default_port))\n        port = int(args[0])\n\n    asyncio.set_event_loop(loop)\n    loop.run_until_complete(main(port))\n\n",
    "start_server.bat": "@echo off\r\nset INSTALL_LOG=atv_pip_install.log\r\nset MY_PATH=%~dp0\r\ncd /d %MY_PATH%\r\n\r\nif not exist env (\r\n    echo ATVRemote - Python install started %DATE% %TIME% >> %INSTALL_LOG%\r\n    echo > setting_up_python\r\n    python -m venv env >> %INSTALL_LOG% 2>&1\r\n    call env\\Scripts\\activate.bat\r\n    python -m pip install --upgrade pip >> %INSTALL_LOG% 2>&1\r\n    python -m pip install websockets pyatv >> %INSTALL_LOG% 2>&1\r\n    echo ATVRemote - Python install ended %DATE% %TIME% >> %INSTALL_LOG%\r\n    echo ================================================== >> %INSTALL_LOG%\r\n) else (\r\n    call env\\Scripts\\activate.bat\r\n)\r\n\r\n:kill_proc\r\nfor /f \"tokens=2 delims= \" %%A in ('tasklist /FI \"IMAGENAME eq python.exe\" /NH') do (\r\n    tasklist /FI \"WINDOWTITLE eq wsserver.py\" | findstr wsserver.py >nul\r\n    if not errorlevel 1 (\r\n        echo Killing %%A\r\n        taskkill /PID %%A /F\r\n    )\r\n)\r\nif exist setting_up_python del setting_up_python\r\npython wsserver.py\r\n",
    "start_server.sh": "#!/bin/bash\nINSTALL_LOG=\"atv_pip_install.log\"\nMY_PATH=$(dirname \"$0\")\ncd \"$MY_PATH\"\nif [[ ! -d env ]]; then\n\tdt=$(date)\n\techo \"ATVRemote - Python install started $dt\" >> $INSTALL_LOG\n\ttouch setting_up_python\n\tpython3 -m venv env | tee -a $INSTALL_LOG\n\tsource env/bin/activate\n\tpython -m pip install --upgrade pip | tee -a $INSTALL_LOG\n\tpython -m pip install websockets pyatv | tee -a $INSTALL_LOG\n\tdt=$(date)\n\techo \"ATVRemote - Python install ended $dt\" >> $INSTALL_LOG\n\techo \"==================================================\" >> $INSTALL_LOG\nelse\n\tsource env/bin/activate\nfi\n\nfunction kill_proc () {\n\tfor p in $(ps ax | grep -v grep | grep wsserver.py | awk '{print $1}'); do\n\t\techo \"Killing $p\"\n\t\tkill $1 $p\n\tdone\n}\nkill_proc\nkill_proc \"-9\"\n[[ -f setting_up_python ]] && rm setting_up_python\npython wsserver.py\n"
};

exports.files = files;
